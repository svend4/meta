# Roadmap реализации: Алгоритмы Франца Германа → Программный код

**Дата:** 19 февраля 2026 г.
**Основа:** 33 PDF-работы Франца Германа, экосистема Q6 как образец архитектуры

---

## Обоснование выбора

Из 33 работ отобраны **8 кандидатов** по критериям:
1. Алгоритм чётко определён и вычислим
2. Нет существующей реализации в открытом доступе (PyPI, GitHub)
3. Есть конкретная аудитория (студенты / учёные / программисты)
4. Вписывается в стиль Q6-монорепо (Python CLI + lib)

Каждый проект оформлен в стиле Q6: `projects/hexXXX/hexXXX.py` + CLI-интерфейс.

---

## Проект 1: `hexnumderiv` — Генетическая теория чисел

**Источник:** PDF `6a4` — «Дифференциальная (генетическая) теория чисел»
**Область:** Теория чисел, образование
**Размер:** ~250 строк

### Алгоритм

Оператор дифференцирования числа:

```
∂n = 1 + сумма всех собственных делителей n (делители < n)

∂1 = 1
∂P = 2           (P — простое: делитель только 1, плюс единица в формуле)
∂6 = 1+1+2+3 = 7
∂(k·m) = k·∂m + m·∂k + ∂k·∂m  (правило Лейбница, если gcd(k,m)=1)
```

Производная порождает цепочку:
```
n → ∂n → ∂(∂n) → ... → 1
```

Классификация чисел:
- **Совершенные:** ∂n = n (например, 6, 28, 496)
- **Супер-числа (СЧ):** цепочка растёт неограниченно (первое: 138 = 2·3·23)
- **Обычные:** цепочка убывает до 1

Огибающая кривая в координатах (N, ∂N):
```
Y = 2√X + 1    — верхняя огибающая
Y = √X + 1     — нижняя огибающая (совершенные квадраты)
```

### Python API

```python
from hexnumderiv import NumberDerivative

nd = NumberDerivative()

# Вычислить производную
nd.derivative(6)       # → 7
nd.derivative(12)      # → 17
nd.derivative(28)      # → 28  (совершенное число)

# Цепочка производных
nd.chain(138)          # → [138, 167, 169, 184, ...]  (супер-число!)
nd.chain(10)           # → [10, 8, 7, 2, 1]

# Классификация
nd.classify(6)         # → "perfect"
nd.classify(138)       # → "super"
nd.classify(10)        # → "ordinary"

# Первые N элементов классов
nd.perfect_numbers(1000)   # → [6, 28, 496]
nd.super_numbers(1000)     # → [138, 276, 414, ...]

# Правило Лейбница (k,m взаимно простые)
nd.leibniz_rule(2, 3)      # → проверка: ∂(2·3) = 2·∂3 + 3·∂2 + ∂2·∂3

# Визуализация "числовой вселенной"
nd.plot_universe(n_max=500)     # ASCII scatter: (N, ∂N) + огибающие
nd.spectrum(n_max=200)          # цветной ASCII-спектр цепочек
```

### CLI

```
python hexnumderiv.py --derivative 138
python hexnumderiv.py --chain 28
python hexnumderiv.py --perfect 10000
python hexnumderiv.py --spectrum 500
python hexnumderiv.py --plot-universe 1000
```

### Почему уникально

Ни numpy, ни sympy, ни sage не имеют встроенного понятия «производной числа» в
смысле Германа. Функция `sum_of_divisors` существует, но:
- нет оператора ∂ как такового
- нет «спектра цепочек» как визуализации
- нет классификации super/ordinary/perfect через эту конструкцию
- нет связи с правилом Лейбница как аналогом дифференцирования

### Аудитория

| Группа | Задача |
|--------|--------|
| Студенты теории чисел | Исследовать делители, совершенные числа |
| Преподаватели | Наглядная демонстрация аналогии анализа и теории чисел |
| Исследователи | Изучение «числовой вселенной» и её статистических свойств |
| Олимпиадники | Задачи на делители с нестандартной формулировкой |

### Интеграция с Q6

Добавить в **hexstat**: статистический анализ распределения ∂n по Q6-состояниям.

---

## Проект 2: `hexintermed` — Промежуточный ряд

**Источник:** PDF `25d` — «Промежуточный ряд»
**Область:** Теория чисел, комбинаторика
**Размер:** ~300 строк

### Алгоритм

Промежуточный ряд H: числа, кратные (2n+1) в интервале (n², (n+1)²).

```
n=1: интервал (1,4), ищем кратные 3: → 3
n=2: интервал (4,9), ищем кратные 5: → 5
n=3: интервал (9,16), ищем кратные 7: → 14
n=4: интервал (16,25), ищем кратные 9: → 18
n=5: интервал (25,36), ищем кратные 11: → 33
...
H = 3, 5, 14, 18, 33, 39, 60, 68, 95, 105, 138, 150, ...
```

Замкнутые формулы:

```python
# Нечётные индексы (n нечётное):
h_odd(n)  = (n+1) * (2*n+1) // 2

# Чётные индексы (n чётное):
h_even(n) = n * (2*n+1) // 2

# Единая формула:
h(n) = (2*n+1) * (2*n+1 - (-1)**n) // 4

# Частичная сумма:
S(n) = (n+1) * (4*(n+1)**2 - 1 - 3*(-1)**n) // 12
```

Связь с многоугольными числами:
```
h(n) = x(n) * y(n),  где x(n) = ⌈n/2⌉,  y(n) = 2n+1
```

k-угольное число:
```
α(n, k) = n * ((k-2)*(n-1) + 2) // 2
```

Квадратные числа: k=4 → n²
Треугольные:      k=3 → n(n+1)/2
Пятиугольные:     k=5 → n(3n-1)/2
Гексагональные:   k=6 → n(2n-1)

### Python API

```python
from hexintermed import IntermediateSeries

h = IntermediateSeries()

# Элементы ряда
h.term(5)           # → 33
h.term(10)          # → 105
h.generate(20)      # → [3, 5, 14, 18, 33, 39, 60, 68, ...]

# Частичные суммы
h.partial_sum(10)   # → сумма первых 10 элементов

# Разложение
h.factorize(5)      # → (x=3, y=11, h=33)  — декомпозиция на x·y

# Рекуррентные соотношения
h.recurrence_check(20)  # → проверяет выполнение рекуррентных тождеств

# Связь с многоугольными числами
h.polygonal(n=5, k=6)          # → 5-й гексагональный номер
h.polygonal_from_h(term_idx=3) # → обратное преобразование

# Свойства симметрии
h.symmetry_check(n=6, k=4, m=2)  # → проверка тождества (40) из PDF

# Визуализация
h.plot(n_max=50)    # ASCII-график ряда H с огибающими n² и (n+1)²
```

### CLI

```
python hexintermed.py --term 100
python hexintermed.py --generate 50
python hexintermed.py --sum 20
python hexintermed.py --polygonal 5 6
python hexintermed.py --plot 50
```

### Почему уникально

Промежуточный ряд H не индексируется в OEIS под этим именем и конструкцией
(единственное кратное нечётного числа в промежутке между последовательными
квадратами). Наличие 9 закрытых формул, 4 видов рекуррентных тождеств и 9
свойств симметрии делает его богатым объектом для реализации. Sage и sympy
работают с многоугольными числами, но данная конструкция отсутствует.

### Аудитория

| Группа | Задача |
|--------|--------|
| Студенты теории чисел | Исследовать числовые ряды с закрытыми формулами |
| Исследователи OEIS | Поиск новых рядов для регистрации |
| Педагоги | Примеры тождеств и доказательств |
| Программисты | Генераторы специальных числовых последовательностей |

### Интеграция с Q6

Добавить в **hexgf**: интерпретация элементов ряда H как элементов GF(2⁶).

---

## Проект 3: `hexscrew` — Группа-винт

**Источник:** PDF `e2c` — «К вопросу о существовании «винта» в Природе» (85 стр.)
**Область:** Теория групп, комбинаторика
**Размер:** ~400 строк

### Алгоритм

Группа-винт Bₙ ⊂ Sₙ — подгруппа всех перестановок степени n, в каждом цикловом
разложении которых присутствует фиксированный цикл длины 1 для элемента «1»:

```
Bₙ = { σ ∈ Sₙ | σ(1) = 1 }
```

Это изоморфно Sₙ₋₁ (действие на {2, 3, ..., n}).

**«Левый» и «правый» спин** элемента группы:

Пусть σ ∈ Sₙ. Разложим на транспозиции. Спин определяется как:
- Знак перестановки restricted на {2..n} (чётная/нечётная)
- left_spin(σ) = +1 если чётная, -1 если нечётная
- right_spin(σ) = произведение длин всех орбит по модулю 2

**Порождающие элементы:**
```
Bₙ порождается транспозициями (i j) где i,j ∈ {2..n}
|Bₙ| = (n-1)!
```

**Действие Bₙ на Q6:**
```
Bₙ действует на гексаграммах: σ переставляет биты 2..6 (бит 1 фиксирован)
Это подгруппа Aut(Q6) порядка 5! = 120
```

### Python API

```python
from hexscrew import ScrewGroup

sg = ScrewGroup(n=5)   # B₅ ⊂ S₅, порядок 24 = 4!

# Базовые операции
sg.order()              # → 24
sg.elements()           # → список всех 24 элементов
sg.is_member([1,3,2,4,5])  # → True (фиксирует 1)
sg.is_member([2,1,3,4,5])  # → False (1 не фиксирован)

# Спин
sg.left_spin([1,3,2,4,5])    # → -1 (нечётная перестановка на {2..5})
sg.right_spin([1,3,2,4,5])   # → +1

# Циклы
sg.cycle_type([1,3,4,2,5])   # → (1)(2 3 4)(5) → [1, 3, 1]
sg.cycles([1,3,4,2,5])       # → [[1], [2,3,4], [5]]

# Операции группы
sg.multiply([1,3,2,4,5], [1,4,3,2,5])  # → произведение
sg.inverse([1,3,2,4,5])                  # → обратный элемент
sg.order_of([1,3,4,2,5])                 # → порядок элемента

# Подгруппы и структура
sg.subgroups()         # → все подгруппы B₅
sg.conjugacy_classes() # → классы сопряжённости
sg.is_normal(subgroup) # → True/False

# Изоморфизм
sg.isomorphism_to_symmetric()   # → биекция B₅ → S₄

# Действие на Q6 (для n=7)
sg7 = ScrewGroup(n=7)
sg7.act_on_hexagram(hexagram=42, perm=[1,3,2,4,5,6,7])  # → переставить биты

# Визуализация
sg.print_cayley_table()   # таблица Кэли
sg.print_lattice()        # решётка подгрупп (ASCII)
```

### CLI

```
python hexscrew.py --order 6
python hexscrew.py --elements 4
python hexscrew.py --spin 1,3,2,4,5
python hexscrew.py --cayley 4
python hexscrew.py --subgroups 5
python hexscrew.py --isomorphism 6
```

### Почему уникально

SymPy имеет `SymmetricGroup`, `AlternatingGroup`, но нет `ScrewGroup(n)` как именованного объекта.
GAP и Sage знают об этой группе как стабилизаторе точки, но не как «группе-винте»
с понятием «спина». Приложение к физике (киральность, винт в природе) — оригинальное.

### Аудитория

| Группа | Задача |
|--------|--------|
| Студенты алгебры | Изучение подгрупп Sₙ, стабилизаторов |
| Физики-теоретики | Моделирование киральности через алгебру |
| Криптографы | Новые перестановочные группы для конструкции S-блоков |
| Исследователи Q6 | Новая подгруппа Aut(Q6) |

### Интеграция с Q6

Напрямую в **hexsym**: добавить `ScrewGroup` как конкретную подгруппу `Aut(Q6)`.
Действие B₆ на 64 гексаграммах — конкретная орбитальная структура для анализа.

---

## Проект 4: `hexmatroot` — Нелинейная теория матриц

**Источник:** PDF `a67` — «Нелинейная теория матриц» (32 стр.)
**Область:** Линейная алгебра, прикладная математика
**Размер:** ~350 строк

### Алгоритм

**1. Оператор инверсии (inversion operator)**

Для матрицы A, матрица Aₒ такая что A · Aₒ = A⁻¹:

```
Для A = [[a, b], [c, d]], det(A) = ad - bc = D:

Aₒ[0,0] = (d² + bc) / D²
Aₒ[0,1] = -b(d + a) / D²
Aₒ[1,0] = -c(d + a) / D²
Aₒ[1,1] = (a² + bc) / D²
```

Свойства:
```
A · Aₒ = Aₒ · A = A⁻¹
det(Aₒ) = 1 / det(A)²
Aₒ = (A⁻¹)²
Aₒ⁻¹ = A²
```

**2. Квадратный корень матрицы (новая формула)**

```
√A = ± (A ± E·√det(A)) / √(tr(A) ± 2·√det(A))

Два сопряжённых корня:
√A₁ = +(A + E·√D) / √(tr(A) + 2√D)
√A₂ = -(A - E·√D) / √(tr(A) - 2√D)

где D = det(A), tr(A) = a + d
```

**3. Условие идемпотентности**

A² = A ⟺ det(A) = 0 И tr(A) = 1.

**4. Матричное уравнение X² + BX + C = 0**

При B = b·E (скалярная матрица):
```
X = -(b/2)·E ± √((b/2)²·E - C)
```

### Python API

```python
from hexmatroot import MatrixAlgebra
import numpy as np

ma = MatrixAlgebra()

A = np.array([[3., 2.], [4., 3.]])

# Оператор инверсии
Ao = ma.inversion_operator(A)
# Ao · A == A^(-1)? → True

# Квадратные корни
roots = ma.sqrt_matrix(A)       # → [√A₁, √A₂] (два корня)
roots[0] @ roots[0]             # ≈ A

# Проверка существования √A
ma.has_sqrt(A)                  # → True / False (с доказательством)

# Идемпотентность
ma.is_idempotent(A)             # → False
B = np.array([[-3., 2.], [-6., 4.]])
ma.is_idempotent(B)             # → True (det=0, tr=1)

# Декомпозиция по корням (Теорема 1)
k1, k2 = ma.decompose_by_roots(A)
# k1*√A₁ + k2*√A₂ ≈ A

# Матрицы Паули и их √
pauli = ma.pauli(1)             # S¹ = [[0,1],[1,0]]
pa_roots = ma.sqrt_matrix(pauli)
ma.cyclic_group_of_4(pauli)     # → таблица Кэли группы {E, √S₁, S, √S₂}

# Решение X² + BX + C = 0
C = np.array([[1., 0.], [0., 1.]])
X_solutions = ma.solve_quadratic(b=2.0, C=C)
for X in X_solutions:
    print(X @ X + 2*X + C)    # ≈ 0

# Семейство корней единичной матрицы
E_roots = ma.identity_sqrt_family(k_values=[1, 2, 3, -1])
for Xk in E_roots:
    print(Xk @ Xk)             # ≈ E
```

### CLI

```
python hexmatroot.py --sqrt "[[3,2],[4,3]]"
python hexmatroot.py --inversion-op "[[3,2],[4,3]]"
python hexmatroot.py --idempotent-check "[[-3,2],[-6,4]]"
python hexmatroot.py --solve-quadratic --b 2 --C "[[1,0],[0,1]]"
python hexmatroot.py --pauli-cyclic 1
```

### Почему уникально

scipy.linalg.sqrtm — существует, но:
- Использует алгоритм Шура: итеративный, не замкнутый
- Нет формулы через det и tr в закрытом виде
- Нет понятия «оператора инверсии» Aₒ
- Нет «сопряжённых корней» √A₁ и √A₂ как отдельных объектов
- Нет построения циклической группы порядка 4 из матрицы

Данная реализация даёт **аналитическое** решение (не итеративное), что важно
для образовательных целей и для символьных вычислений.

### Аудитория

| Группа | Задача |
|--------|--------|
| Студенты линейной алгебры | Изучить матричные корни с явной формулой |
| Физики (матрицы Паули) | Анализ групп, порождённых матрицами Паули |
| Инженеры | Замкнутые формулы для 2×2 систем |
| Исследователи алгебры | Нелинейные расширения матричных операций |

### Интеграция с Q6

В **hexmat**: добавить нелинейные операции над матрицами GF(2)
(матрицы из GL(6,2) — не вещественные, но идемпотентность и структура корней аналогичны).

---

## Проект 5: `hexperms` — Алгоритм нахождения перестановок

**Источник:** PDF `17f` — «Алгоритм нахождения перестановок» (3 стр.)
**Область:** Комбинаторика, алгоритмы
**Размер:** ~200 строк

### Алгоритм

Автор предлагает алгоритм систематического перебора перестановок через
сканирование по «основанию k»: на каждом шаге выбирается следующий незанятый
элемент в позиции i, что обеспечивает лексикографический порядок без рекурсии.

Ключевые отличия от Heap's Algorithm и Steinhaus–Johnson–Trotter:
- Нет рекурсии (итеративный)
- Лексикографический порядок на выходе
- Прямой доступ к k-й перестановке по номеру (unranking)

**Unranking** (получить k-ю перестановку по порядковому номеру):

```
Факторадическая система счисления:
k-я перестановка из n элементов:
digits = factoradic(k, n)
perm = []
pool = list(range(1, n+1))
for d in digits:
    perm.append(pool.pop(d))
return perm
```

**Алгоритм Германа** (сканирование):

```
Генерация следующей перестановки (in-place, лексикограф.):
1. Найти наибольший i такой что perm[i] < perm[i+1]
2. Найти наибольший j такой что perm[i] < perm[j]
3. Поменять perm[i] и perm[j]
4. Обратить суффикс perm[i+1:]
```

### Python API

```python
from hexperms import PermutationEngine

pe = PermutationEngine(n=5)

# Генерация всех перестановок
for p in pe.generate_all():
    print(p)                     # 120 перестановок в лексикограф. порядке

# Следующая/предыдущая перестановка
p = [1, 3, 2, 5, 4]
pe.next_perm(p)                  # → [1, 3, 4, 2, 5]
pe.prev_perm(p)                  # → [1, 3, 2, 4, 5]

# Unranking: k-я перестановка по номеру
pe.unrank(0)                     # → [1, 2, 3, 4, 5]
pe.unrank(119)                   # → [5, 4, 3, 2, 1]
pe.unrank(60)                    # → середина упорядочения

# Ranking: номер данной перестановки
pe.rank([1, 3, 2, 5, 4])        # → позиция в лексикограф. порядке

# Перестановки с ограничениями
pe.with_fixed_point(1)           # → перестановки, где p[0]=1 (группа-винт B₅!)
pe.derangements()                # → перестановки без неподвижных точек

# Бенчмарк против itertools
pe.benchmark(n=10)               # → сравнение скорости с itertools.permutations

# Применение к Q6 (6-битные перестановки = Aut(Q6))
pe6 = PermutationEngine(n=6)
pe6.generate_aut_q6()            # → 720 перестановок позиций Q6
```

### CLI

```
python hexperms.py --all 5
python hexperms.py --unrank 60 --n 5
python hexperms.py --rank "1,3,2,5,4"
python hexperms.py --next "1,3,2,5,4"
python hexperms.py --derangements 5
python hexperms.py --benchmark 10
```

### Почему уникально

`itertools.permutations` — существует, но не имеет:
- Unranking/ranking (прямой доступ к k-й перестановке за O(n))
- Генерации только подмножеств (фиксированная точка, без неподвижных точек)
- Бенчмаркинга собственного алгоритма автора

Алгоритм из PDF `17f` имеет образовательную ценность как самостоятельная реализация,
независимая от itertools — важно для студентов, изучающих алгоритмы.

### Аудитория

| Группа | Задача |
|--------|--------|
| Студенты CS | Реализация и анализ алгоритмов перебора |
| Алгоритмисты | Сравнение методов генерации перестановок |
| Преподаватели | Учебный материал по факториадической системе |
| Q6-разработчики | Генерация подгрупп Aut(Q6) |

---

## Проект 6: `hextile` — Апериодические мозаики

**Источник:** PDF `0f6` + `194` — «К вопросу апериодической мозаики плоскости» + «Теория квазикристаллических мозаик на правильных многоугольниках»
**Область:** Дискретная геометрия, визуализация
**Размер:** ~500 строк

### Алгоритм

**Тип плитки Германа (PDF 0f6):**

Предлагается новый апериодический тип плитки — стрела из двух ромбов,
где угол подобран так что никакие три плитки не образуют ни квадрат, ни ромб.
Правила укладки: каждый угол 36°, 72°, 108° должен быть покрыт с
конкретным сочетанием цветов/типов соседних плиток.

**Квазикристаллическая мозаика на правильных многоугольниках (PDF 194):**

Алгоритм размещения симметричного паттерна на:
- n-угольнике (n = 3, 4, 5, 6, 8, 10, 12)
- Правило: каждая сторона делится на k частей, по правилу «сдвига» строится
  новый узор с 5-кратной (10-кратной) симметрией

**Конструкция двумерного поля плиток:**

```
1. Начать с центральной плитки
2. Обход по BFS: для каждого открытого ребра подобрать допустимую плитку
3. Проверить совместимость углов (constraint propagation)
4. Если нет допустимой — backtrack (или relaxation)
```

### Python API

```python
from hextile import AperiodicTiler, QuasicrystalMosaic

# Апериодическая мозаика Германа
tiler = AperiodicTiler(tile_type="herman")

# Разместить N плиток
tiling = tiler.generate(n_tiles=200, seed=42)

# Визуализация
tiler.to_svg("output.svg")         # SVG-файл
tiler.to_ascii(width=80)           # ASCII-арт

# Проверка апериодичности
tiler.has_translational_symmetry() # → False (апериодическая)
tiler.symmetry_group()             # → "5-fold" / "10-fold" / ...

# Квазикристаллическая мозаика
qm = QuasicrystalMosaic(polygon_sides=8, divisions=5)
mosaic = qm.generate()
qm.to_svg("mosaic.svg")
qm.to_ascii(width=60)

# Сравнение с Penrose
penrose = AperiodicTiler(tile_type="penrose")
penrose.generate(n_tiles=100)
penrose.to_svg("penrose.svg")

# Экспорт для hexca (плитки → начальные конфигурации 2D CA)
tiling.to_hexca_grid(width=32, height=32)  # → numpy array 32×32 со значениями 0..63
```

### CLI

```
python hextile.py --generate 200 --type herman --svg output.svg
python hextile.py --mosaic --polygon 8 --divisions 5 --svg mosaic.svg
python hextile.py --ascii 200 --width 80
python hextile.py --compare penrose --n 100
python hextile.py --hexca-grid 32 32
```

### Почему уникально

Плитки Пенроуза (1974), Эйнштейн-тайл (2023) — реализованы в tilings.py и других
библиотеках. Плитка Германа — **отдельный тип**: его конкретная конструкция из PDF
нигде не реализована. «Квазикристаллические мозаики на правильных многоугольниках»
(PDF 194) — оригинальный класс паттернов с конкретным алгоритмом.

### Аудитория

| Группа | Задача |
|--------|--------|
| Математики | Проверка апериодичности нового типа плиток |
| Дизайнеры | Уникальные декоративные паттерны |
| Материаловеды | Моделирование квазикристаллов |
| Художники | Генерация узоров для визуального искусства |
| Q6-исследователи | Нестандартные начальные конфигурации для hexca |

---

## Проект 7: `hexhept` — Единственность гептаэдра

**Источник:** PDF `8dd` — «Единственность гептаэдра?»
**Область:** Комбинаторная топология, многогранники
**Размер:** ~400 строк

### Алгоритм

**Структура гептаэдра (модель RP²):**

```
Вершины: 6 (A, B, C, D, E, F)
Грани: 7 (4 треугольника + 3 квадрата)
Рёбра: 12
χ = B + Γ - P = 6 + 7 - 12 = 1  (= χ(RP²))
```

**Алгоритм проверки «модели RP²»:**

Условия для выпуклого многогранника быть моделью RP²:
```
1. χ = B + Γ - P = 1
2. Каждое ребро граничит ровно с 2 гранями: ΣC_Γ = 2P
3. Условие добавления/удаления граней: Γ_Y - Γ_D = 1
4. Балансовое условие рёбер: Γ_И · (n+1) = Γ_B · n
```

**Алгоритм перебора кандидатов:**

```python
for polyhedron in candidate_polyhedra:
    # Проверить условие 3 (face addition)
    if not satisfies_face_condition(polyhedron):
        reject(polyhedron, reason="face_addition")
        continue
    # Проверить балансовое условие рёбер
    n = find_n(polyhedron)
    if not is_integer(n):
        reject(polyhedron, reason="edge_balance_not_integer")
        continue
    # Проверить фактическую укладку рёбер
    if not valid_edge_covering(polyhedron, internal_faces):
        reject(polyhedron, reason="no_valid_edge_cover")
        continue
    accept(polyhedron)
```

**Формулы гептаэдра:**

```
Длина ребра = a
Площадь поверхности: S = a²√3 · (1 + √3)
Псевдо-объём:        V = a³√2 / 6
Изоморфизм сфере: x₁² + x₂² + x₃² = 1  (при нормировке площадей подграней)
```

### Python API

```python
from hexhept import Heptahedron, RP2Checker

# Гептаэдр
h = Heptahedron(edge_length=1.0)

# Свойства
h.vertices()            # → 6 трёхмерных точек
h.faces()               # → 7 граней (4 треугольника + 3 квадрата)
h.edges()               # → 12 рёбер
h.euler_characteristic()# → 1
h.surface_area()        # → 1²·√3·(1+√3) ≈ 3.48
h.pseudo_volume()       # → 1³·√2/6 ≈ 0.236
h.is_rp2_model()        # → True

# Разбивка граней → изоморфизм единичной сфере
h.sphere_isomorphism()  # → x₁²+x₂²+x₃²=1 (из суб-площадей AOF, AOB, BOF)

# Сетка (развёртка)
h.net()                 # → плоская развёртка (список 2D точек)
h.net_to_svg("net.svg") # → SVG-файл развёртки

# Проверка произвольных многогранников
checker = RP2Checker()

# Икосаэдр — подходит?
checker.check_icosahedron()     # → False, n=3/2 не целое

# Кубооктаэдр — подходит?
checker.check_cuboctahedron()   # → False

# Кастомный многогранник
checker.check_custom(
    vertices=6, faces=7, edges=12,
    face_types={"triangle": 4, "square": 3}
)                               # → (True, details)

# Полный перебор: все многогранники с χ=1 и V≤20
results = checker.enumerate_rp2_candidates(max_vertices=8)
for r in results:
    print(r.polyhedron, "→", r.verdict, r.reason)
```

### CLI

```
python hexhept.py --properties --edge 1.0
python hexhept.py --net --svg net.svg
python hexhept.py --check-rp2 --vertices 6 --faces 7 --edges 12
python hexhept.py --enumerate --max-vertices 8
python hexhept.py --sphere-isomorphism
```

### Почему уникально

Ни в SageMath, ни в polymake, ни в coxeter нет специализированного инструмента
для проверки «является ли многогранник моделью RP²». Данная конструкция (гептаэдр
как минимальная модель RP²) используется в учебниках по алгебраической топологии,
но не как программная библиотека. Алгоритм перебора и отсева кандидатов — оригинален.

### Аудитория

| Группа | Задача |
|--------|--------|
| Топологи | Исследование минимальных полиэдральных моделей поверхностей |
| Студенты геометрии | Понять конструкцию RP² через многогранники |
| 3D-художники | Создать модель гептаэдра для рендеринга |
| Математики-комбинаторы | Перебор многогранников с заданной топологией |

---

## Проект 8: `hexmobius` — Аналитическая теория поверхностей Мёбиуса

**Источник:** PDF `65b` — «Аналитическая теория мёбиусовых поверхностей» (29 стр.)
**Область:** Топология, вычислительная геометрия
**Размер:** ~450 строк

### Алгоритм

**Стандартная лента Мёбиуса:**

```
Параметризация:
x(u,v) = (R + v·cos(u/2))·cos(u)
y(u,v) = (R + v·cos(u/2))·sin(u)
z(u,v) = v·sin(u/2)

где u ∈ [0, 2π],  v ∈ [-1, 1],  R = радиус
```

**Расширенные варианты Германа:**

```
Класс 1 (полуширина w, N скручиваний):
z(u,v) = v·sin(N·u/2)

Класс 2 (конусообразная):
x = (R + v·cos(u/2)·cos(φ))·cos(u)
y = (R + v·cos(u/2)·sin(φ))·sin(u)
z = v·sin(u/2)·f(φ)

Класс 3 (бутылка Клейна — вырожденный случай, N=2):
замкнутая, неориентируемая, χ=0
```

**Топологические инварианты (вычислимые):**

```python
# Характеристика Эйлера:
χ(лента Мёбиуса) = 0
χ(стандартный тор) = 0
χ(бутылка Клейна) = 0
χ(RP²)            = 1

# Ориентируемость (через нормальный вектор):
orientable = (∮ n dA ≠ 0)  # False для Мёбиуса

# Число краёв:
num_edges(стандартная лента) = 1
num_edges(цилиндр)           = 2

# Число скручиваний (writhing number):
writhe = (1/2π) ∮ τ(s) ds   # τ — кривизна кручения осевой кривой
```

**3D-координаты → экспорт:**

```
OBJ-формат: вершины + треугольники UV-сетки
STL-формат: для 3D-печати
```

### Python API

```python
from hexmobius import MobiusSurface, SurfaceTopology

# Стандартная лента Мёбиуса
mb = MobiusSurface(R=3.0, width=1.0, twists=1)

# Точки поверхности
pts = mb.points(u_steps=100, v_steps=20)  # → array (100×20, 3)

# Топологические свойства
mb.euler_characteristic()    # → 0
mb.is_orientable()           # → False
mb.num_boundary_components() # → 1
mb.writhing_number()         # → 0.5 (у стандартной)

# Нормальный вектор в точке
mb.normal(u=1.5, v=0.3)      # → (nx, ny, nz)

# Площадь поверхности
mb.surface_area()            # → числовое значение

# Экспорт
mb.to_obj("mobius.obj")      # Wavefront OBJ
mb.to_stl("mobius.stl")      # STL для 3D-печати
mb.to_svg_projection("xz")   # 2D-проекция в SVG

# Расширенные классы
mb2 = MobiusSurface(R=3.0, width=1.0, twists=2)  # Klein bottle
mb2.is_orientable()           # → False
mb2.num_boundary_components() # → 0

mb3 = MobiusSurface(R=3.0, width=1.0, twists=0)  # Цилиндр
mb3.is_orientable()           # → True
mb3.num_boundary_components() # → 2

# Сравнение классов
topo = SurfaceTopology()
topo.compare([mb, mb2, mb3])  # → таблица инвариантов

# ASCII-визуализация (проекция)
mb.ascii_project(width=60, view="xz")
```

### CLI

```
python hexmobius.py --standard --radius 3 --width 1 --twists 1
python hexmobius.py --topology --twists 2
python hexmobius.py --export obj --output mobius.obj
python hexmobius.py --ascii --view xz --width 60
python hexmobius.py --compare 0 1 2 3
```

### Почему уникально

matplotlib + numpy позволяют нарисовать ленту Мёбиуса, но нет специализированной
библиотеки с:
- Полным набором топологических инвариантов (χ, ориентируемость, компоненты края)
- Систематической классификацией по числу скручиваний
- Экспортом в OBJ/STL (для 3D-печати)
- Сравнительными таблицами для учебных целей

### Аудитория

| Группа | Задача |
|--------|--------|
| Студенты топологии | Изучить поверхности через вычисления инвариантов |
| 3D-художники | Генерировать необычные поверхности для рендеринга/печати |
| Преподаватели | Наглядное введение в топологические инварианты |
| Математики | Систематическая классификация поверхностей |

---

## Сводная таблица всех 8 проектов

| # | Проект | PDF | Строк | Уникальность | Аудитория | Интеграция с Q6 |
|---|--------|-----|-------|--------------|-----------|-----------------|
| 1 | **hexnumderiv** | 6a4 | 250 | ∂n не реализован нигде | Студенты, исследователи | hexstat |
| 2 | **hexintermed** | 25d | 300 | H-ряд не индексирован в OEIS | Числовики, педагоги | hexgf |
| 3 | **hexscrew** | e2c | 400 | ScrewGroup нет в sympy/sage | Алгебраисты, физики | hexsym |
| 4 | **hexmatroot** | a67 | 350 | Аналитич. √A-формулы vs scipy | Матем., инженеры | hexmat |
| 5 | **hexperms** | 17f | 200 | Unranking + алгоритм автора | CS-студенты, алгоритмисты | hexsym |
| 6 | **hextile** | 0f6+194 | 500 | Плитка Германа нигде не реализована | Геометры, дизайнеры | hexca |
| 7 | **hexhept** | 8dd | 400 | RP²-checker нет нигде | Топологи, студенты | hexgraph |
| 8 | **hexmobius** | 65b | 450 | Классификация+экспорт в одном | Топологи, 3D-художники | hexvis |

**Итого:** ~2 850 строк Python, 8 новых проектов, 0 существующих аналогов (полных).

---

## Приоритеты реализации

### Tier 1 — Реализовать в первую очередь (простой алгоритм + высокий спрос)

```
hexnumderiv   ← формулы простые, спрос высокий, аудитория широкая
hexperms      ← 3 страницы PDF → 200 строк кода, чистый алгоритм
hexintermed   ← замкнутые формулы, легко тестировать
```

### Tier 2 — Реализовать вторыми (умеренная сложность + высокая уникальность)

```
hexscrew      ← важнейший для Q6 (подгруппа Aut(Q6)), большой PDF
hexmatroot    ← практический (инженеры используют 2×2 системы)
hexhept       ← уникальная топологическая задача
```

### Tier 3 — Реализовать третьими (высокая сложность + специализированная аудитория)

```
hextile       ← нужно верифицировать апериодичность
hexmobius     ← нужен 3D-рендеринг
```

---

## Структура каждого проекта (по образцу Q6)

```
projects/
├── hexnumderiv/
│   ├── hexnumderiv.py      # основная библиотека + CLI
│   ├── test_hexnumderiv.py # тесты
│   └── README.md
├── hexintermed/
│   ├── hexintermed.py
│   ├── test_hexintermed.py
│   └── README.md
...
```

Каждый модуль:
1. Импортируется как библиотека: `from hexnumderiv import NumberDerivative`
2. Запускается как CLI: `python hexnumderiv.py --chain 138`
3. Имеет тесты с проверкой по числовым примерам из PDF
4. Не требует зависимостей кроме numpy (для матричных проектов)

---

*Документ подготовлен на основе: анализа 33 PDF Франца Германа,
экстракции алгоритмов (агент), сравнения с экосистемой Q6.*
